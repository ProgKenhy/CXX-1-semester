                        //a$ = 0 - Эта команда на языке ассемблера объявляет переменную "a$" и инициализирует ее значением 0
void foo_if()           //void foo_if(void) PROC - Объявляет функцию с именем "foo_if".
{                       //$LN5: - Метка, которая определяет точку в программе, к которой можно перейти.
                        //sub rsp, 24 - Выделяет память на стеке для локальных переменных.
    int a = 1;          //mov DWORD PTR a$[rsp], 1 - Сохраняет значение 1 в переменной "a$".
    if (a == 1)         //cmp DWORD PTR a$[rsp], 1 - Сравнивает значение переменной "a$" с 1.
                        //jne SHORT $LN2@foo_if - Переходит к метке $LN2@foo_if, если значения не равны.
        a = a + 10;     //mov eax, DWORD PTR a$[rsp] - Загружает значение переменной "a$" в регистр eax.
                        //add eax, 10 - Прибавляет 10 к значению в регистре eax.
                        //mov DWORD PTR a$[rsp], eax - Сохраняет новое значение в переменной "a$".
                        //jmp SHORT $LN3@foo_if - Переходит к метке $LN3@foo_if.
    else                //$LN2@foo_if: - Метка, которая определяет точку в программе, к которой можно перейти.
        a = a * 2;      //mov eax, DWORD PTR a$[rsp] - Загружает значение переменной "a$" в регистр eax.
                        //shl eax, 1 - Сдвигает значение в регистре eax на 1 бит влево (умножение на 2).
                        //mov DWORD PTR a$[rsp], eax - Сохраняет новое значение в переменной "a$".
                        //$LN3@foo_if: - Метка, которая определяет точку в программе, к которой можно перейти.
 }                      //add rsp, 24 - Освобождает память на стеке, выделенную ранее.
                        //ret 0 - Возвращает управление из функции.
        

                        //a$ = 0: Создается переменная a$ и ей присваивается значение 0.
                        //tv64 = 4: Создается переменная tv64 и ей присваивается значение 4.
void foo_switch()       //void foo_switch(void) PROC: Начало определения функции с именем foo_switch, без аргументов.
{                       //$LN7: - Метка, которая определяет точку в программе, к которой можно перейти.
                        //sub rsp, 24: Выделяется 24 байта памяти в стеке для локальных переменных.
    int a = 0;          //mov DWORD PTR a$[rsp], 0: Помещает значение 0 в переменную a$ в стеке.
    switch (a)          //mov eax, DWORD PTR a$[rsp]: Загружает значение переменной a$ из стека в регистр eax.
                        //mov DWORD PTR tv64[rsp], eax: Помещает значение из регистра eax в переменную tv64 в стеке.
                        //cmp DWORD PTR tv64[rsp], 0: Сравнивает значение переменной tv64 с 0.
                        //je SHORT $LN4@foo_switch: Если значение равно 0, переходит к метке $LN4@foo_switch.
                        //cmp DWORD PTR tv64[rsp], 1: Сравнивает значение переменной tv64 с 1.
                        //je SHORT $LN5@foo_switch: Если значение равно 1, переходит к метке $LN5@foo_switch.
                        //jmp SHORT $LN2@foo_switch: Переходит к метке $LN2@foo_switch.
    {
    case 0: a = a + 10; //$LN4@foo_switch: Метка для перехода при условии tv64 равно 0.
                        //mov eax, DWORD PTR a$[rsp]: Загружает значение переменной a$ из стека в регистр eax.
                        //add eax, 10: Прибавляет 10 к значению в регистре eax.
                        //mov DWORD PTR a$[rsp], eax: Помещает значение из регистра eax обратно в переменную a$ в стеке.
        break;          //jmp SHORT $LN2@foo_switch: Переходит к метке $LN2@foo_switch.
    case 1: a = a * 2;  //$LN5@foo_switch: Метка для перехода при условии tv64 равно 1.
                        //mov eax, DWORD PTR a$[rsp]: Загружает значение переменной a$ из стека в регистр eax.
                        //shl eax, 1: Умножает значение в регистре eax на 2.
                        //mov DWORD PTR a$[rsp], eax: Помещает значение из регистра eax обратно в переменную a$ в стеке.
        break;          //$LN2@foo_switch: Метка для перехода после выполнения условий.
    }
}                       //add rsp, 24: Освобождает 24 байта памяти в стеке.
                        //ret 0: Возвращает значение из функции.


                        //a$ = 0 присваивает переменной a$ значение 0.
                        //tv67 = 4 присваивает переменной tv67 значение 4.
void foo_ternary()      //void foo_switch(void) PROC: Начало определения функции с именем foo_switch, без аргументов.
{                       //$LN5: - Метка, которая определяет точку в программе, к которой можно перейти.
    int a = 0;          //sub rsp, 24: Выделяется 24 байта памяти в стеке для локальных переменных.
    a = a == 1 ? a + 10 : a * 2;    //mov DWORD PTR a$[rsp], 0 присваивает переменной a$ в стеке значение 0.
                        //cmp DWORD PTR a$[rsp], 1 сравнивает значение переменной a$ в стеке с 1.
                        //jne SHORT $LN3@foo_ternar переходит к метке $LN3@foo_ternar, если значения не равны.
                        //mov eax, DWORD PTR a$[rsp] присваивает переменной eax значение переменной a$ в стеке.
                        //add eax, 10 добавляет к значению eax число 10.
                        //mov DWORD PTR tv67[rsp], eax присваивает переменной tv67 в стеке значение eax.
                        //jmp SHORT $LN4@foo_ternar переходит к метке $LN4@foo_ternar.
                        //mov eax, DWORD PTR a$[rsp] присваивает переменной eax значение переменной a$ в стеке
                        //shl eax, 1 умножает значение eax на 2.
                        //mov DWORD PTR tv67[rsp], eax присваивает переменной tv67 в стеке значение eax.
                        //mov eax, DWORD PTR tv67[rsp] присваивает переменной eax значение переменной tv67 в стеке.
                        //mov DWORD PTR a$[rsp], eax присваивает переменной a$ в стеке значение eax.
}                       //add rsp, 24 освобождает 24 байта в стеке.
                        //ret 0 возвращает управление из функции.
